---
title: "Live Plinko based on the Economist's model"
author: "Matthew Kay"
output: github_document
---

This document builds a Plinko board based on the Economist's model for use in (semi-live) forecasting on election night.

## Setup

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(purrr)
library(Hmisc)
library(ggdist)
library(ragg)
library(patchwork)
library(gganimate)
library(snakecase)
library(ggtext)
library(plinko)     # devtools::install_github("mjskay/plinko")

theme_set(theme_ggdist())
```

### Live data model

The live data model is accessible via code provided by G. Elliot Morris:

```{r}
# source("election_night_live_model.R")
```

We then get an updated EV sample by providing called states for Biden and Trump. Names available are:

```{r}
names(ev)
```

And we wrap up the distribution of predicted EVs using `update_prob()`:

```{r}
biden_states = c("VT",  
  "VA", "CT", "DE", "IL", "MD", "MA", "NJ", "RI",
  "NM", "NY",
  "DC", "CO",
  "WA", "OR", "CA", "NH",
  "HI",
  
  "MN",
  
  "NE2",
  "ME1", "ME",
  "WI"
)
trump_states = c("KY",  
  "WV", "SC", "AL", "MS", "OK", "TN",
  "AR", "IN", "LA", "ND", "SD", "WY", "NE",
  "KS",
  "NE3", "MO", "ID",
  "UT", "OH",
  "MT", "IA", "FL",
  
  "TX",
  "NE1",
  "ME2"
)

df_econ = data.frame(dem_ev = update_prob(
  biden_states = biden_states,
  trump_states = trump_states
))
```

```{r}
setdiff(names(ev), c(biden_states, trump_states))
```


We will plot a histogram of Biden's predicted probability of achieving each number of electoral votes (with 270 being a majority). We'll also do a side-by-side comparison:

```{r}
col_269 = "#1b9e77"

base_plot_econ = df_econ %>%
  ggplot(aes(x = dem_ev)) +
  geom_histogram(aes(y = stat(density)), binwidth = 1, fill = "gray75") +
  geom_vline(xintercept = 269, color = col_269, size = 1) +
  annotate("label", x = 269, y = .061, label = "269", color = col_269, size = 3) +
  xlab("Electoral votes for Biden") +
  scale_y_continuous(breaks = NULL) +
  ylab("") +
  coord_cartesian(xlim = c(0, 540)) +
  ggtitle("The Economist")

base_plot_econ
```

## Normal approximation

Let's approximate this distribution with a normal distribution by simply using the mean and variance of the predictive distribution:

```{r}
mean_ev_econ = mean(df_econ$dem_ev)
# var_ev_econ = var(df_econ$dem_ev)
# sd_ev_econ = sd(df_econ$dem_ev)
# using mad instead of sd since it seems to do a bit 
# better at making an okay approx on the economist distribution
sd_ev_econ = mad(df_econ$dem_ev)
var_ev_econ = sd_ev_econ^2
```

And plot:

```{r}
col_normal = "#7570b3"

normal_plot = function(base_plot, mean_ev, sd_ev) {
  normal_density = tibble(x = 1:538, y = dnorm(x, mean_ev, sd_ev))
  
  base_plot + 
    geom_line(aes(x = x, y = y), data = normal_density, color = col_normal, size = 1)
}

normal_plot(base_plot_econ, mean_ev_econ, sd_ev_econ)
```

The Normal approximation looks decent. Let's continue down this train a bit and use binomial approximations to the Normal by finding a binomial distribution with the same variance and then shifting its location to match the above Normal distribution.

## Binomial approximation

We can use the fact that the variance of a Binomial distribution with probability 0.5 is equal to 1/4 the number of trials in the distribution to find the number of trials needed (which is the same as the height of the Galton board we would need to construct):

```{r}
bin_n_econ = round(4 * var_ev_econ)
bin_n_econ
```

That would be a very large Galton board! Leaving that aside for a moment, let's see how well it approximates the distributions:

```{r}
col_binom = "#d95f02"

binom_plot = function(base_plot, mean_ev, sd_ev, bin_n) {
  binom_mass = tibble(x = 0:538, y = dbinom(x + round(bin_n/2 - mean_ev), bin_n, 0.5))
  normal_plot(base_plot, mean_ev, sd_ev) +
    geom_step(aes(x = x, y = y), data = binom_mass, color = col_binom, direction = "mid", size = 1)
}

binom_plot(base_plot_econ, mean_ev_econ, sd_ev_econ, bin_n_econ)
```

The binomial distribution looks nearly identical to the Normal distribution here. However, like I said, it would require very large Galton boards to generate these distributions down to the single electoral vote level. So instead, let's use wider bins --- say, bins between 35 and 45 electoral votes wide. In fact, we'll pick a single bin width that we can use for both distirbutions that puts 269 as close to a bin boundary in both as we can, given the scaling/shifting of the distribution we will be doing: 

```{r}
candidate_bin_width = 25:43
candidate_bin_n_econ = round(4 * var_ev_econ / candidate_bin_width^2)
# minimize sum of squared distance between 269 and the nearest 
# bin edge in both 538 and the economist's distribution
bin_width = candidate_bin_width[which.min(
  abs((269/candidate_bin_width + candidate_bin_n_econ/2 - mean_ev_econ/candidate_bin_width) %% 1 - 0.5)
)]
bin_width
```

That gives us a bin width of `r bin_width`, leading to...

```{r}
bin_n_small_econ = round(4 * var_ev_econ / bin_width^2)
bin_n_small_econ
```

A Galton board with a much more manageable number of bins. Let's check on the approximation:

```{r}
binom_plot_small = function(base_plot, mean_ev, sd_ev, bin_n) {
  binom_mass_small = tibble(
    x = 0:538, 
    y = dbinom(round(x/bin_width + bin_n/2 - mean_ev/bin_width), bin_n, 0.5) / bin_width
  )
  
  normal_plot(base_plot, mean_ev, sd_ev) +
    geom_step(aes(x = x, y = y), data = binom_mass_small, color = col_binom, direction = "mid", size = 1)
}

binom_plot_small(base_plot_econ, mean_ev_econ, sd_ev_econ, bin_n_small_econ)
```

### Fudging the mean

In case a bin boundary doesn't line up exactly at 269, we'll adjust the means a little bit so that it does. Since
we've already picked a binning to minimize the distance between 269 and its closest bin boundary, this shouldn't
require us to fudge the mean too much:

```{r}
mean_ev_adj_econ = mean_ev_econ + ((269 + bin_n_small_econ*bin_width/2 - mean_ev_econ) %% bin_width - bin_width/2)

cat(sep = "",
  "\t\tMean\tAdjusted mean", 
  "\nEconomist:\t", round(mean_ev_econ, 1), "\t", mean_ev_adj_econ
)
```

That should make a bin boundary fall on 269 without the approximation looking too bad:

```{r}
binom_plot_small(base_plot_econ, mean_ev_adj_econ, sd_ev_econ, bin_n_small_econ)
```

## Quantiles for the dotplot

We want the distributions at the bottom of the board to be a 
[quantile dotplot](https://github.com/mjskay/when-ish-is-my-bus/blob/master/quantile-dotplots.md)
so that it is representative of the predictors' distributions. We'll use
50 quantiles; i.e. a 50-dot dotplot:

```{r}
n_ball = 35

ev_quantiles_econ = quantile(df_econ$dem_ev, ppoints(n_ball))

print(mean(df_econ$dem_ev < 269))
print(mean(ev_quantiles_econ < 269))
```

## Create Plinko boards

Finally, we can construct an animated Plinko board using my experimental 
[plinko](https://mjskay.github.io/plinko/) package. This package handles 
finding paths through the board and generating the animation for us.

The final parameters for the approximation are:

```{r}
cat(paste0(
  "bins:      ", bin_n_small_econ, "\n",
  "bin width: ", bin_width, "\n",
  "mean:      ", mean_ev_adj_econ, "\n"
))
```

We can test the layout before building the animation:

```{r, fig.height = 5.5, fig.width = 5.5}
Biden_color = "#0571b0"
Trump_color = "#ca0020"

# dimensions we will use to override dims automatically calculated by 
# plinko_board() so that both boards have the same dimensions
total_height = 1600
slot_height = 566
width_px = 550
height_px = 550

format_state_list = function(states) {
  if (is.null(states)) {
    "No calls yet"
  } else {
    paste(stringi::stri_wrap(paste(sort(states), collapse = " "), width = 33, indent = 4), collapse = "<br>")
  }
}

make_plinko_board = function(model_name, ...) {
  plinko_board(..., 
    bin_width = bin_width,
    limits = c(0, 538),
    slot_height = slot_height,
    frames_till_drop = bin_n_small_econ + 4,
    stack = FALSE,
  ) %>%
    tween_balls(frame_mult = 2) %>%
    modify_layer("pins", color = "gray50") %>%
    modify_layer("balls", aes(fill = 
      ifelse(stopped_for > 2, "done",
      ifelse(region != "slot", "none",
      ifelse(x <= 269, "Trump", "Biden")))
    )) %>%
    modify_coord(ylim = c(0, total_height), xlim = c(-45, -45 + total_height)) %>%
    add_layers(
      geom_vline(xintercept = 269, color = "black", alpha = 0.15, size = 1),
      annotate("text", 
        x = 290, y = 0.93 * total_height, 
        label = "Biden wins", hjust = 0, color = Biden_color
      ),
      annotate("text", 
        x = 250, y = 0.93 * total_height,
        label = "Trump wins", hjust = 1, color = Trump_color
      ),
      annotate("label", 
        x = 269, y = 0.98 * total_height,
        label = "269", hjust = 0.5, color = "gray50",
        fontface = "bold"
      ),
      annotate("richtext",
        x = 650, y = 0,
        label = paste0(
          "<strong style='color: black;'>Presidential-Plinko.com Semi-Live Board</strong><br><br>",
          "Updated ", format(Sys.time(), format = "%b %d %I:%M %p", tz = "EST", usetz = TRUE), "<br><br>",
          "Based on the Economist's model<br>and these state-level calls:<br><br>",
          "Biden: ", format_state_list(biden_states), "<br><br>",
          "Trump: ", format_state_list(trump_states), "<br><br>",
          "Each ball is <strong>one possible outcome</strong> of the<br>",
          "election. When a ball lands above 269,<br>",
          "<strong style='color:", Biden_color, "';>Biden wins.</strong> When a ball lands below 269,<br>",
          "<strong style='color:", Trump_color, "';>Trump wins.</strong> The more often the ball lands<br>",
          "above 269, the more likely Biden will win."
        ),
        color = "gray25",
        hjust = 0, label.color = NA, label.padding = unit(c(0, 0, 0, 0), "lines"),
        vjust = 0
      ),
      stat_histinterval(
        aes(x = dem_ev),
        data = df_econ,
        slab_fill = "gray25",
        scale = slot_height * 0.9,
        alpha = 0.15,
        show_interval = FALSE
      ),
      annotate("segment", x = -50, y = 0, xend = 538 + 50, yend = 0, size = 1, color = "gray75"),
      scale_fill_manual(
        limits = c("done", "none", "Biden", "Trump"),
        values = c(NA, "gray45", Biden_color, Trump_color), 
        guide = FALSE
      ),
      scale_x_continuous(breaks = c(0, 135, 269, 405, 538)),
      theme_ggdist(),
      theme(
        axis.line.y = element_blank(),
        axis.line.x = element_blank(),
        axis.title.x = element_text(hjust = 0, size = 10, color = "gray25"),
        plot.title = element_text(hjust = 0),
        plot.title.position = "plot"
      ),
      labs(
        x = paste0("Electoral votes for Biden"),
        y = NULL
      ),
      ggtitle(NULL)
    )
}

set.seed(12345)
board_econ = make_plinko_board(
  model_name = "The Economist",
  ev_quantiles_econ, 
  n_bin = bin_n_small_econ, 
  center = mean_ev_adj_econ
)

autoplot(board_econ, show_dist = FALSE, show_paths = FALSE)
```

Looks good! Let's build the animation:

```{r}
options(mc.cores = 6)
board_econ %>%
  animate(width = width_px, height = height_px, fps = 15, cores = 7)
```

And save it to a file:

```{r}
anim_save("boards/live_galton_board.gif")
```
